import typing as t
from collections import defaultdict
from dataclasses import dataclass
from enum import Enum
from pathlib import Path


class TreeElements(Enum):
    space = "    "
    branch = "│   "
    tee = "├── "
    last = "└── "

    def __repr__(self) -> str:
        return f"TreeElements.{self.name}"


class FileFormat(Enum):

    directory = "directories"
    markdown = "markdown"
    image = "image"
    audio = "audio"
    video = "video"
    pdf = "pdf"
    other = "other"

    @classmethod
    def from_extension(cls, extension: str) -> t.Optional["FileFormat"]:
        map = {
            ".3gp": cls.audio,
            ".bmp": cls.image,
            ".flac": cls.audio,
            ".gif": cls.image,
            ".jpeg": cls.image,
            ".jpg": cls.image,
            ".m4a": cls.audio,
            ".md": cls.markdown,
            ".mkv": cls.video,
            ".mov": cls.video,
            ".mp3": cls.audio,
            ".mp4": cls.video,
            ".ogg": cls.audio,
            ".ogv": cls.video,
            ".pdf": cls.pdf,
            ".png": cls.image,
            ".svg": cls.image,
            ".wav": cls.audio,
            ".webm": cls.video,
        }
        return map.get(extension.lower(), cls.other)


@dataclass(frozen=True)
class IndexLine:
    elements: t.Tuple[TreeElements]
    path: Path

    def __repr__(self) -> str:
        return "".join(e.value for e in self.elements) + f" {self.path.name}"


Summary = t.DefaultDict[FileFormat, int]


@dataclass(frozen=True)
class Index:
    root: Path
    lines: t.Tuple[IndexLine]
    summary: Summary

    @classmethod
    def create(
        cls,
        dir_path: t.Union[Path, str],
    ) -> "Index":
        dir_path = Path(dir_path)
        summary = defaultdict(int)

        def inner(dir_path: Path, prefix: t.Sequence[TreeElements] = ()) -> t.Tuple[t.Sequence[TreeElements], Path]:
            nonlocal summary
            contents = list(dir_path.iterdir())
            elements = [TreeElements.tee] * (len(contents) - 1) + [TreeElements.last]
            for element, path in zip(elements, contents):
                if path.is_dir():
                    yield IndexLine(prefix + (element,), path)
                    summary[FileFormat.directory] += 1
                    extension = TreeElements.branch if element == TreeElements.tee else TreeElements.space
                    yield from inner(path, prefix=prefix + (extension,))
                else:
                    yield IndexLine(prefix + (element,), path)
                    summary[FileFormat.from_extension(path.suffix)] += 1

        return cls(root=dir_path, lines=tuple(inner(dir_path)), summary=summary)

    def __repr__(self) -> str:
        return (
            f"{self.root.name}\n"
            + "\n".join(repr(line) for line in self.lines)
            + f"\n\n{dict((f.value, c) for f, c in self.summary.items())}"  # noqa: C402
        )


def render_doc_link(path: Path) -> str:
    if " " in path.name:
        return f"[{path.name}](<{str(path)}>)"
    return f"[{path.name}]({str(path)})"


SUMMARY_TEMPLATE = """
| File Format | Count |
| :---        |  ---: |
{summary_lines}
"""


def render_summary_line(format: FileFormat, count: int) -> str:
    return f"| {format.value} | {count} |"


def render_summary(summary: Summary) -> str:
    return SUMMARY_TEMPLATE.format(summary_lines="\n".join(render_summary_line(f, summary[f]) for f in FileFormat))


INDEX_TEMPLATE = """
# Index

<sub>Do not edit this file, it is auto-generated.</sub>

**{dir_name}**
{rendered_index}

## Summary
{rendered_summary}"""


def render_index_line(line: IndexLine, root: t.Optional[Path] = None) -> str:
    doc_link = line.path.relative_to(root) if root else line.path
    return "".join(e.value for e in line.elements) + render_doc_link(doc_link)


def render(index: Index) -> str:
    return INDEX_TEMPLATE.format(
        dir_name=index.root.name,
        rendered_index="\n".join(render_index_line(line, index.root) for line in index.lines),
        rendered_summary=render_summary(index.summary),
    )


def build_index(path: str) -> str:
    index = Index.create(path)
    return render(index)
