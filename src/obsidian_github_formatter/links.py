import re
import typing as t
from pathlib import Path

from pca.packages.errors import (
    ErrorCatalog,
    error_builder,
)

from .cache import Cache
from .config import Config
from .console import (
    color_diff,
    color_header,
)
from .errors import Errors
from .files import (
    FileFormat,
    ProcessedFile,
    diff_files,
    read_file,
    save_file,
)
from .index import Index
from .repository import (
    Submodule,
    get_submodules,
)


def process_file(filename: str, cache: Cache) -> None:
    process_file: ProcessedFile = cache.get_value("get_processed_file")
    with process_file:
        process_file.set(Path(filename))
        original_text = read_file(filename)
        formatted_text = repair_links(original_text, cache)
        if original_text != formatted_text:
            if not cache.get_value("dry_run"):
                save_file(filename, formatted_text, make_backups=cache.get_value("make_backups"))
            else:
                _print(color_header(f"File '{filename}' would be modified. Here's the diff:"))
                diff = diff_files(original_text, formatted_text)
                _print("\n".join(color_diff(diff)))


def _print(text: str) -> None:  # pragma: no cover
    print(text)


_WIKILINK_STRUCTURE = re.compile(r"\[\[(.*?)\]\]")
_DEAD_LINK_SIGN = " ❌"
_AMBIGUOUS_LINK_SIGN = " ↔"


class LinksErrors(ErrorCatalog):
    DeadLink = error_builder()
    AmbiguousLink = error_builder()


def repair_links(contents: str, cache: Cache) -> str:
    # TODO differentiate special parts of document
    return _WIKILINK_STRUCTURE.sub(lambda m: substitute_wikilink_format(m.group(1), cache), contents)


def substitute_wikilink_format(contents: str, cache: Cache) -> str:
    index: Index = cache.get_value("build_index")
    prefix: str = cache.get_value("link_prefix", "")
    errors: Errors = cache.get_value("get_errors")
    processed_file: ProcessedFile = cache.get_value("get_processed_file")
    bracket_l = bracket_r = ""

    link = contents.strip("[]")
    if "|" in contents:
        link, title = link.rsplit("|", 1)
    else:
        title = None
    paths = index.file_map.get(link, None)
    if not paths:
        if not (path := _autogenerate_document_for_link(cache, link)):
            errors.append(LinksErrors.DeadLink(target=link, title=title, file=str(processed_file.filepath)))
            return f"[[{contents}|{title or link}{_DEAD_LINK_SIGN}]]"
    elif len(paths) > 1:  # pragma: no cover
        errors.append(
            LinksErrors.AmbiguousLink(
                target=link, target_files=[str(p) for p in paths], file=str(processed_file.filepath)
            )
        )
        return f"[[{contents}|{title or link}{_AMBIGUOUS_LINK_SIGN}]]"
    else:
        path = paths[0]
    path_str = str(path)
    if " " in path_str or " " in prefix:
        bracket_l = "<"
        bracket_r = ">"
    if title is None:
        title = link
    title = _clean_good_title(title)
    url = _substitute_submodules(cache, path) or f"{prefix}/{path}"
    return f"[{title}]({bracket_l}{url}{bracket_r})"


def _substitute_submodules(cache: Cache, path: Path) -> t.Optional[str]:
    submodules: t.Dict[Path, Submodule] = cache.get_value(get_submodules)
    root: Path = cache.get_value("vault_root")

    for submodule in submodules:
        assert isinstance(submodule, Submodule)
        if submodule.path in (root / path).parents:
            return submodule.substitute(root / path)
    return


_AUTOGENERATED_DOCUMENT_TEMPLATE = "<sub>This file was autogenerated.</sub>\n"


def _autogenerate_document_for_link(cache: Cache, link: str) -> t.Optional[Path]:
    config: Config = cache.get_value("get_config")
    if (
        link
        and (autogenerate_dir := config.links.autogenerate_dir)
        and FileFormat.from_link(link) == FileFormat.markdown
    ):
        filepath: Path = cache.get_value("vault_root") / autogenerate_dir / f"{link}.md"
        contents = config.links.autogenerate_template or _AUTOGENERATED_DOCUMENT_TEMPLATE
        save_file(filepath, contents)
        notifications: list = cache.get_value("get_notifications")
        notifications.append(f"File autogenerated: {str(filepath)}")
        return filepath


def _clean_good_title(title: str) -> str:
    if _DEAD_LINK_SIGN in title:
        title = title.replace(_DEAD_LINK_SIGN, "")
    if _AMBIGUOUS_LINK_SIGN in title:
        title = title.replace(_AMBIGUOUS_LINK_SIGN, "")
    return title
